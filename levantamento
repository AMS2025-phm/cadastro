import React, { useState, useEffect } from 'react';
import { initializeApp } from 'firebase/app';
import { getAuth, signInAnonymously, signInWithCustomToken, onAuthStateChanged } from 'firebase/auth';
import { getFirestore, doc, getDoc, addDoc, setDoc, updateDoc, deleteDoc, onSnapshot, collection, query, where, getDocs } from 'firebase/firestore';
// import * as XLSX from 'xlsx'; // Removido: XLSX será carregado via CDN

// Variáveis globais fornecidas pelo ambiente Canvas
// Revertido para usar as variáveis globais do ambiente Canvas
const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
const firebaseConfig = typeof __firebase_config !== 'undefined' ? JSON.parse(__firebase_config) : {};
const initialAuthToken = typeof __initial_auth_token !== 'undefined' ? __initial_auth_token : null;


// Constantes para tipos de dados
const TIPOS_PISO = [
    "Paviflex", "Cerâmica", "Porcelanato", "Granilite",
    "Cimento Queimado", "Epoxi", "Ardósia", "Outros"
];
const TIPOS_MEDIDA = ["Vidro", "Sanitário-Vestiário", "Área Interna", "Área Externa"];
const TIPOS_PAREDE = ["Alvenaria", "Estuque", "Divisórias"];

function App() {
    // Estados para Firebase e autenticação
    const [db, setDb] = useState(null);
    const [auth, setAuth] = useState(null);
    const [userId, setUserId] = useState(null);
    const [isAuthReady, setIsAuthReady] = useState(false); // Garante que operações Firestore esperem pela autenticação

    // Estados para os dados do formulário
    const [localidades, setLocalidades] = useState({}); // Armazena todas as localidades e unidades
    const [nomeLocalidade, setNomeLocalidade] = useState('');
    const [unidade, setUnidade] = useState('');
    const [data, setData] = useState(new Date().toISOString().slice(0, 10)); // Data atual no formato YYYY-MM-DD
    const [responsavel, setResponsavel] = useState('');
    const [vidrosAltos, setVidrosAltos] = useState('Não');
    const [estacionamento, setEstacionamento] = useState(false);
    const [gramado, setGramado] = useState(false);
    const [curativo, setCurativo] = useState(false);
    const [vacina, setVacina] = useState(false);
    const [qtdFunc, setQtdFunc] = useState('');

    // Estados para checkboxes de múltiplos itens
    const [pisoVars, setPisoVars] = useState(
        Object.fromEntries(TIPOS_PISO.map(p => [p, false]))
    );
    const [paredeVars, setParedeVars] = useState(
        Object.fromEntries(TIPOS_PAREDE.map(p => [p, false]))
    );
    const [tipoMedidaVars, setTipoMedidaVars] = useState(
        Object.fromEntries(TIPOS_MEDIDA.map(p => [p, false]))
    );

    // Estados para medidas
    const [comprimento, setComprimento] = useState('');
    const [largura, setLargura] = useState('');
    const [medidas, setMedidas] = useState([]); // Armazena objetos { tipo, comp, larg, area }

    // Estados para seleção de itens em listas
    const [selectedMedidaIndex, setSelectedMedidaIndex] = useState(null);
    const [selectedLocalidadeUnit, setSelectedLocalidadeUnit] = useState(null); // { localidade, unidade }

    // Estado para mensagens de feedback ao usuário
    const [message, setMessage] = useState({ show: false, type: '', text: '' });

    // Efeito para inicialização do Firebase e autenticação
    useEffect(() => {
        if (Object.keys(firebaseConfig).length === 0) {
            console.error("A configuração do Firebase está faltando. Verifique as variáveis de ambiente.");
            showMessage('error', "Configuração do Firebase ausente. Verifique as variáveis de ambiente.");
            return;
        }

        try {
            const app = initializeApp(firebaseConfig);
            const firestoreDb = getFirestore(app);
            const firebaseAuth = getAuth(app);
            setDb(firestoreDb);
            setAuth(firebaseAuth);

            // Listener para mudanças no estado de autenticação
            onAuthStateChanged(firebaseAuth, async (user) => {
                if (user) {
                    setUserId(user.uid);
                    console.log("ID do usuário autenticado:", user.uid);
                } else {
                    console.log("Nenhum usuário logado. Tentando login anônimo.");
                    try {
                        // Usando initialAuthToken se disponível, caso contrário, login anônimo
                        if (initialAuthToken) {
                            await signInWithCustomToken(firebaseAuth, initialAuthToken);
                            console.log("Logado com token personalizado.");
                        } else {
                            await signInAnonymously(firebaseAuth);
                            console.log("Logado anonimamente.");
                        }
                    } catch (error) {
                        console.error("Erro de autenticação do Firebase:", error);
                        showMessage('error', `Erro de autenticação: ${error.message}`);
                    }
                }
                setIsAuthReady(true); // O estado de autenticação está pronto
            });
        } catch (error) {
            console.error("Erro ao inicializar o Firebase:", error);
            showMessage('error', `Erro ao inicializar Firebase: ${error.message}`);
        }
    }, []);

    // Efeito para o listener do Firestore (carrega dados em tempo real)
    useEffect(() => {
        // Garante que db, userId e isAuthReady estejam disponíveis antes de tentar carregar dados
        if (db && userId && isAuthReady) {
            // Define o caminho da coleção no Firestore para dados privados do usuário
            const localidadesColRef = collection(db, `artifacts/${appId}/users/${userId}/localidades`);
            
            // onSnapshot para ouvir mudanças em tempo real
            const unsubscribe = onSnapshot(localidadesColRef, (snapshot) => {
                const fetchedLocalidades = {};
                snapshot.forEach(doc => {
                    const data = doc.data();
                    const { localidade, unidade, ...rest } = data;
                    if (!fetchedLocalidades[localidade]) {
                        fetchedLocalidades[localidade] = {};
                    }
                    // Armazena o ID do documento junto com os dados
                    fetchedLocalidades[localidade][unidade] = { id: doc.id, ...rest };
                });
                setLocalidades(fetchedLocalidades);
                console.log("Localidades carregadas do Firestore:", fetchedLocalidades);
            }, (error) => {
                console.error("Erro ao carregar localidades do Firestore:", error);
                showMessage('error', `Erro ao carregar localidades: ${error.message}`);
            });

            return () => unsubscribe(); // Função de limpeza para desinscrever o listener
        }
    }, [db, userId, isAuthReady, appId]); // Dependências do efeito

    // Função para exibir mensagens ao usuário
    const showMessage = (type, text) => {
        setMessage({ show: true, type, text });
        setTimeout(() => setMessage({ show: false, type: '', text: '' }), 5000); // Esconde após 5 segundos
    };

    // Função para adicionar uma medida à lista
    const adicionarMedida = () => {
        try {
            const selectedTipos = Object.entries(tipoMedidaVars)
                .filter(([, isChecked]) => isChecked)
                .map(([tipo]) => tipo);

            if (selectedTipos.length === 0) {
                showMessage('warning', "Selecione ao menos um tipo de medida.");
                return;
            }
            const comp = parseFloat(comprimento.replace(",", ".")); // Converte vírgula para ponto para parseFloat
            const larg = parseFloat(largura.replace(",", "."));

            if (isNaN(comp) || isNaN(larg) || comp <= 0 || larg <= 0) {
                showMessage('error', "Comprimento e largura devem ser números positivos.");
                return;
            }

            const area = comp * larg;
            const newMedidas = [...medidas];
            for (const tipo of selectedTipos) {
                newMedidas.push({ tipo, comp, larg, area }); // Adiciona como objeto
            }
            setMedidas(newMedidas);
            setComprimento(''); // Limpa campos após adicionar
            setLargura('');
            // Desmarca todos os tipos de medida selecionados
            setTipoMedidaVars(Object.fromEntries(TIPOS_MEDIDA.map(p => [p, false])));
        } catch (error) {
            console.error("Erro ao adicionar medida:", error);
            showMessage('error', "Erro ao adicionar medida. Verifique os valores.");
        }
    };

    // Função para excluir uma medida da lista
    const excluirMedida = () => {
        if (selectedMedidaIndex !== null) {
            const newMedidas = medidas.filter((_, index) => index !== selectedMedidaIndex);
            setMedidas(newMedidas);
            setSelectedMedidaIndex(null); // Limpa a seleção
        } else {
            showMessage('warning', "Selecione uma medida para excluir.");
        }
    };

    // Função para repetir uma medida na lista
    const repetirMedida = () => {
        if (selectedMedidaIndex !== null) {
            // Usa prompt para obter a quantidade de repetições (pode ser substituído por um modal customizado)
            const count = prompt("Quantas vezes repetir essa medida?", "1");
            const numCount = parseInt(count, 10);
            if (!isNaN(numCount) && numCount > 0) {
                const medidaToRepeat = medidas[selectedMedidaIndex];
                const newMedidas = [...medidas];
                for (let i = 0; i < numCount; i++) {
                    newMedidas.push(medidaToRepeat);
                }
                setMedidas(newMedidas);
            } else if (count !== null) { // Se o usuário digitou algo mas não é um número válido
                showMessage('warning', "Por favor, insira um número válido e positivo.");
            }
        } else {
            showMessage('warning', "Selecione uma medida para repetir.");
        }
    };

    // Função para salvar uma unidade no Firestore
    const salvarUnidade = async () => {
        // Verifica se o Firebase está pronto
        if (!db || !userId) {
            showMessage('error', "Firebase não está pronto. Tente novamente.");
            return;
        }

        const local = nomeLocalidade.trim();
        const unit = unidade.trim();
        if (!local || !unit) {
            showMessage('warning', "Localidade e unidade são obrigatórias.");
            return;
        }

        // Prepara o objeto de informação para salvar
        const info = {
            localidade: local,
            unidade: unit,
            data: data,
            responsavel: responsavel,
            piso: Object.entries(pisoVars).filter(([, isChecked]) => isChecked).map(([p]) => p),
            vidros_altos: vidrosAltos,
            paredes: Object.entries(paredeVars).filter(([, isChecked]) => isChecked).map(([p]) => p),
            estacionamento: estacionamento,
            gramado: gramado,
            curativo: curativo,
            vacina: vacina,
            qtd_func: qtdFunc,
            medidas: medidas // Armazena como array de objetos
        };

        try {
            // Verifica se a unidade já existe para esta localidade
            const q = query(collection(db, `artifacts/${appId}/users/${userId}/localidades`),
                where("localidade", "==", local),
                where("unidade", "==", unit)
            );
            const querySnapshot = await getDocs(q);

            if (!querySnapshot.empty) {
                // Se o documento existe, atualiza-o
                const docToUpdate = querySnapshot.docs[0];
                await setDoc(doc(db, `artifacts/${appId}/users/${userId}/localidades`, docToUpdate.id), info);
                showMessage('success', "Unidade atualizada com sucesso.");
            } else {
                // Se não existe, adiciona um novo documento
                await addDoc(collection(db, `artifacts/${appId}/users/${userId}/localidades`), info);
                showMessage('success', "Unidade salva com sucesso.");
            }
        } catch (e) {
            console.error("Erro ao salvar documento: ", e);
            showMessage('error', `Erro ao salvar unidade: ${e.message}`);
        }
    };

    // Função para carregar os dados de uma localidade selecionada no formulário
    const carregarLocalidade = (local, unit) => {
        setSelectedLocalidadeUnit({ localidade: local, unidade: unit });
        const info = localidades[local]?.[unit];
        if (info) {
            setNomeLocalidade(local);
            setUnidade(unit);
            setData(info.data || '');
            setResponsavel(info.responsavel || '');
            setVidrosAltos(info.vidros_altos || 'Não');
            // Atualiza os estados dos checkboxes com base nos dados carregados
            setPisoVars(Object.fromEntries(TIPOS_PISO.map(p => [p, info.piso?.includes(p) || false])));
            setParedeVars(Object.fromEntries(TIPOS_PAREDE.map(p => [p, info.paredes?.includes(p) || false])));
            setEstacionamento(info.estacionamento || false);
            setGramado(info.gramado || false);
            setCurativo(info.curativo || false);
            setVacina(info.vacina || false);
            setQtdFunc(info.qtd_func || '');
            setMedidas(info.medidas || []); // Carrega as medidas
        }
    };

    // Função para limpar todos os campos do formulário
    const limparCampos = () => {
        setUnidade('');
        setData(new Date().toISOString().slice(0, 10));
        setResponsavel('');
        setQtdFunc('');
        setVidrosAltos('Não');
        // Desmarca todos os checkboxes
        setPisoVars(Object.fromEntries(TIPOS_PISO.map(p => [p, false])));
        setParedeVars(Object.fromEntries(TIPOS_PAREDE.map(p => [p, false])));
        setTipoMedidaVars(Object.fromEntries(TIPOS_MEDIDA.map(p => [p, false])));
        setEstacionamento(false);
        setGramado(false);
        setCurativo(false);
        setVacina(false);
        setMedidas([]); // Limpa as medidas
        setSelectedMedidaIndex(null);
        setSelectedLocalidadeUnit(null);
    };

    // Função para exportar para Excel e simular envio de e-mail
    const exportarExcelEEmail = async () => {
        if (!db || !userId) {
            showMessage('error', "Firebase não está pronto. Tente novamente.");
            return;
        }

        if (Object.keys(localidades).length === 0) {
            showMessage('warning', "Não há dados para exportar.");
            return;
        }

        try {
            // Cria uma nova pasta de trabalho do Excel
            const wb = XLSX.utils.book_new(); // XLSX agora está disponível globalmente

            // Itera sobre todas as localidades e unidades para criar as planilhas
            for (const local in localidades) {
                for (const unit in localidades[local]) {
                    const info = localidades[local][unit];

                    // Cria a aba de Detalhes para cada unidade
                    const ws_detalhe_data = [
                        ["Localidade", "Unidade", "Data", "Responsável", "Tipo de Piso", "Vidros Altos", "Paredes", "Estacionamento", "Gramado", "Sala de Curativo", "Sala de Vacina", "Qtd Funcionários"],
                        [
                            local, unit, info.data || "", info.responsavel || "",
                            info.piso?.join(", ") || "", info.vidros_altos || "",
                            info.paredes?.join(", ") || "",
                            info.estacionamento ? "Sim" : "Não",
                            info.gramado ? "Sim" : "Não",
                            info.curativo ? "Sim" : "Não",
                            info.vacina ? "Sim" : "Não",
                            info.qtd_func || ""
                        ]
                    ];
                    const ws_detalhe = XLSX.utils.aoa_to_sheet(ws_detalhe_data);
                    // Adiciona a aba à pasta de trabalho, truncando o nome para 31 caracteres
                    XLSX.utils.book_append_sheet(wb, ws_detalhe, `Detalhe_${local}_${unit}`.substring(0, 31));

                    // Prepara os dados para as abas de medidas
                    const abasData = {
                        "Vidro": [],
                        "Área Interna": [],
                        "Sanitário-Vestiário": [],
                        "Área Externa": []
                    };

                    for (const medida of info.medidas || []) {
                        const { tipo, comp, larg, area } = medida;
                        if (abasData[tipo]) {
                            abasData[tipo].push([local, unit, comp, larg, area.toFixed(2)]);
                        }
                    }

                    // Cria as abas de medidas se houver dados
                    for (const tipo in abasData) {
                        if (abasData[tipo].length > 0) {
                            const sheetData = [
                                ["Localidade", "Unidade", "Comprimento (m)", "Largura (m)", "Área (m²)"],
                                ...abasData[tipo]
                            ];
                            const ws_medida = XLSX.utils.aoa_to_sheet(sheetData);
                            XLSX.utils.book_append_sheet(wb, ws_medida, `${tipo}_${local}_${unit}`.substring(0, 31));
                        }
                    }
                }
            }

            // Gera o arquivo Excel e faz o download
            const excelFileName = `Cadastro_Localidades_${new Date().toISOString().slice(0, 10)}.xlsx`;
            XLSX.writeFile(wb, excelFileName);

            showMessage('success', "Planilha Excel gerada com sucesso!");

            // Simula o envio de e-mail usando a API Gemini
            const prompt = `Crie um corpo de e-mail formal para enviar a planilha Excel "${excelFileName}" para comercialservico2025@gmail.com.
            O e-mail deve indicar que a planilha contém os dados de cadastro de localidades e medidas por unidade.
            Sugira que o anexo deve ser verificado e agradeça pela atenção.`;

            const payload = {
                contents: [{ role: "user", parts: [{ text: prompt }] }],
            };
            const apiKey = ""; // A chave da API será fornecida pelo Canvas em tempo de execução
            const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=${apiKey}`;

            showMessage('info', 'Gerando corpo do e-mail e simulando envio...');

            const response = await fetch(apiUrl, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(payload)
            });

            const result = await response.json();

            if (result.candidates && result.candidates.length > 0 &&
                result.candidates[0].content && result.candidates[0].content.parts &&
                result.candidates[0].content.parts.length > 0) {
                const emailBody = result.candidates[0].content.parts[0].text;
                console.log("Corpo do e-mail gerado:\n", emailBody);
                showMessage('success', "Corpo do e-mail gerado. (O envio real da planilha requer um serviço de backend).");
                // Em uma aplicação real, você enviaria este emailBody e o arquivo Excel via um serviço de backend.
                // Exemplo: fetch('/api/send-email', { method: 'POST', body: JSON.stringify({ to: 'comercialservico2025@gmail.com', subject: 'Dados de Cadastro de Localidades', body: emailBody, attachment: excelFileBlob }) });
            } else {
                console.error("Erro ao gerar corpo do e-mail:", result);
                showMessage('error', "Erro ao gerar corpo do e-mail. (O envio real da planilha requer um serviço de backend).");
            }

        } catch (error) {
            console.error("Erro ao exportar Excel ou simular e-mail:", error);
            showMessage('error', `Erro ao exportar Excel ou simular e-mail: ${error.message}`);
        }
    };

    return (
        // Contêiner principal do aplicativo com estilos Tailwind CSS
        <div className="min-h-screen bg-blue-50 p-4 font-sans flex flex-col items-center">
            {/* Scripts e links para Tailwind CSS e fonte Inter */}
            <script src="https://cdn.tailwindcss.com"></script>
            <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet" />
            {/* Adicionado: Script para carregar a biblioteca XLSX via CDN */}
            <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
            {/* Estilos CSS customizados para mensagens e componentes */}
            <style>
                {`
                body { font-family: 'Inter', sans-serif; }
                .message-box {
                    position: fixed;
                    top: 20px;
                    right: 20px;
                    padding: 15px 20px;
                    border-radius: 8px;
                    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
                    z-index: 1000;
                    display: flex;
                    align-items: center;
                    gap: 10px;
                }
                .message-box.success { background-color: #d4edda; color: #155724; border: 1px solid #c3e6cb; }
                .message-box.error { background-color: #f8d7da; color: #721c24; border: 1px solid #f5c6cb; }
                .message-box.warning { background-color: #fff3cd; color: #856404; border: 1px solid #ffeeba; }
                .message-box.info { background-color: #d1ecf1; color: #0c5460; border: 1px solid #bee5eb; }
                /* Estilos para botões */
                .button-primary {
                    @apply bg-blue-700 text-white px-4 py-2 rounded-lg hover:bg-blue-800 transition-colors duration-200 shadow-md;
                }
                .button-secondary {
                    @apply bg-gray-300 text-gray-800 px-4 py-2 rounded-lg hover:bg-gray-400 transition-colors duration-200 shadow-md;
                }
                /* Estilos para campos de entrada */
                .input-field {
                    @apply p-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500;
                }
                .label-text {
                    @apply text-gray-700 font-medium mb-1;
                }
                /* Estilos para cartões/seções */
                .card {
                    @apply bg-white p-6 rounded-xl shadow-lg mb-6 w-full max-w-4xl;
                }
                /* Estilos para listboxes */
                .listbox {
                    @apply border border-gray-300 rounded-lg overflow-auto;
                }
                .listbox-item {
                    @apply p-2 cursor-pointer hover:bg-blue-100;
                }
                .listbox-item.selected {
                    @apply bg-blue-200;
                }
                `}
            </style>

            {/* Caixa de mensagens (exibida condicionalmente) */}
            {message.show && (
                <div className={`message-box ${message.type}`}>
                    <span>{message.text}</span>
                </div>
            )}

            {/* Cartão principal do formulário */}
            <div className="card">
                <h1 className="text-3xl font-bold text-center text-gray-800 mb-6">Cadastro de Localidades e Medidas</h1>
                {/* Exibe o ID do usuário */}
                <p className="text-center text-sm text-gray-600 mb-4">
                    ID do Usuário: <span className="font-mono bg-gray-200 px-2 py-1 rounded">{userId || 'Carregando...'}</span>
                </p>

                {/* Seção de campos de entrada */}
                <div className="grid grid-cols-1 md:grid-cols-2 gap-4 mb-6">
                    <div>
                        <label className="label-text">Localidade</label>
                        <input type="text" className="input-field w-full" value={nomeLocalidade} onChange={(e) => setNomeLocalidade(e.target.value)} />
                    </div>
                    <div>
                        <label className="label-text">Unidade</label>
                        <input type="text" className="input-field w-full" value={unidade} onChange={(e) => setUnidade(e.target.value)} />
                    </div>
                    <div>
                        <label className="label-text">Data</label>
                        <input type="date" className="input-field w-full" value={data} onChange={(e) => setData(e.target.value)} />
                    </div>
                    <div>
                        <label className="label-text">Responsável pela unidade</label>
                        <input type="text" className="input-field w-full" value={responsavel} onChange={(e) => setResponsavel(e.target.value)} />
                    </div>
                    <div>
                        <label className="label-text">Quantidade de Funcionário</label>
                        <input type="text" className="input-field w-full" value={qtdFunc} onChange={(e) => setQtdFunc(e.target.value)} />
                    </div>
                </div>

                {/* Seção de Tipo de Piso */}
                <div className="mb-6">
                    <label className="label-text block mb-2">Tipo de Piso</label>
                    <div className="grid grid-cols-2 sm:grid-cols-3 md:grid-cols-4 gap-2">
                        {TIPOS_PISO.map(piso => (
                            <div key={piso} className="flex items-center">
                                <input
                                    type="checkbox"
                                    id={`piso-${piso}`}
                                    className="mr-2 rounded-md text-blue-600 focus:ring-blue-500"
                                    checked={pisoVars[piso]}
                                    onChange={(e) => setPisoVars({ ...pisoVars, [piso]: e.target.checked })}
                                />
                                <label htmlFor={`piso-${piso}`}>{piso}</label>
                            </div>
                        ))}
                    </div>
                </div>

                {/* Seção de Vidros Altos */}
                <div className="mb-6">
                    <label className="label-text block mb-2">Vidros Altos</label>
                    <div className="flex gap-4">
                        <label className="flex items-center">
                            <input
                                type="radio"
                                name="vidrosAltos"
                                value="Sim"
                                className="mr-2 text-blue-600 focus:ring-blue-500"
                                checked={vidrosAltos === 'Sim'}
                                onChange={(e) => setVidrosAltos(e.target.value)}
                            />
                            Sim
                        </label>
                        <label className="flex items-center">
                            <input
                                type="radio"
                                name="vidrosAltos"
                                value="Não"
                                className="mr-2 text-blue-600 focus:ring-blue-500"
                                checked={vidrosAltos === 'Não'}
                                onChange={(e) => setVidrosAltos(e.target.value)}
                            />
                            Não
                        </label>
                    </div>
                </div>

                {/* Seção de Paredes */}
                <div className="mb-6">
                    <label className="label-text block mb-2">Paredes</label>
                    <div className="flex flex-wrap gap-4">
                        {TIPOS_PAREDE.map(parede => (
                            <div key={parede} className="flex items-center">
                                <input
                                    type="checkbox"
                                    id={`parede-${parede}`}
                                    className="mr-2 rounded-md text-blue-600 focus:ring-blue-500"
                                    checked={paredeVars[parede]}
                                    onChange={(e) => setParedeVars({ ...paredeVars, [parede]: e.target.checked })}
                                />
                                <label htmlFor={`parede-${parede}`}>{parede}</label>
                            </div>
                        ))}
                    </div>
                </div>

                {/* Seção de Outras Informações (Estacionamento, Gramado, Curativo, Vacina) */}
                <div className="mb-6">
                    <label className="label-text block mb-2">Outras Informações</label>
                    <div className="grid grid-cols-2 sm:grid-cols-2 md:grid-cols-4 gap-2">
                        <label className="flex items-center">
                            <input type="checkbox" className="mr-2 rounded-md text-blue-600 focus:ring-blue-500" checked={estacionamento} onChange={(e) => setEstacionamento(e.target.checked)} />
                            Estacionamento
                        </label>
                        <label className="flex items-center">
                            <input type="checkbox" className="mr-2 rounded-md text-blue-600 focus:ring-blue-500" checked={gramado} onChange={(e) => setGramado(e.target.checked)} />
                            Gramado
                        </label>
                        <label className="flex items-center">
                            <input type="checkbox" className="mr-2 rounded-md text-blue-600 focus:ring-blue-500" checked={curativo} onChange={(e) => setCurativo(e.target.checked)} />
                            Sala de Curativo
                        </label>
                        <label className="flex items-center">
                            <input type="checkbox" className="mr-2 rounded-md text-blue-600 focus:ring-blue-500" checked={vacina} onChange={(e) => setVacina(e.target.checked)} />
                            Sala de Vacina
                        </label>
                    </div>
                </div>

                {/* Seção de Medidas */}
                <div className="mb-6">
                    <h2 className="text-xl font-semibold text-gray-800 mb-4">Medidas</h2>
                    <div className="grid grid-cols-1 md:grid-cols-2 gap-4 mb-4">
                        <div>
                            <label className="label-text">Comprimento (m)</label>
                            <input type="text" className="input-field w-full" value={comprimento} onChange={(e) => setComprimento(e.target.value)} />
                        </div>
                        <div>
                            <label className="label-text">Largura (m)</label>
                            <input type="text" className="input-field w-full" value={largura} onChange={(e) => setLargura(e.target.value)} />
                        </div>
                    </div>

                    <div className="mb-4">
                        <label className="label-text block mb-2">Tipos de Medida</label>
                        <div className="flex flex-wrap gap-4">
                            {TIPOS_MEDIDA.map(tipo => (
                                <div key={tipo} className="flex items-center">
                                    <input
                                        type="checkbox"
                                        id={`tipo-medida-${tipo}`}
                                        className="mr-2 rounded-md text-blue-600 focus:ring-blue-500"
                                        checked={tipoMedidaVars[tipo]}
                                        onChange={(e) => setTipoMedidaVars({ ...tipoMedidaVars, [tipo]: e.target.checked })}
                                    />
                                    <label htmlFor={`tipo-medida-${tipo}`}>{tipo}</label>
                                </div>
                            ))}
                        </div>
                    </div>

                    {/* Botões de ação para medidas */}
                    <div className="flex flex-wrap gap-4 mb-4">
                        <button className="button-primary" onClick={adicionarMedida}>Adicionar Medida</button>
                        <button className="button-secondary" onClick={excluirMedida}>Excluir Medida</button>
                        <button className="button-secondary" onClick={repetirMedida}>Repetir Medida</button>
                    </div>

                    {/* Lista de medidas adicionadas */}
                    <div className="listbox h-32">
                        {medidas.length === 0 ? (
                            <p className="p-2 text-gray-500">Nenhuma medida adicionada.</p>
                        ) : (
                            medidas.map((medida, index) => (
                                <div
                                    key={index}
                                    className={`listbox-item ${selectedMedidaIndex === index ? 'selected' : ''}`}
                                    onClick={() => setSelectedMedidaIndex(index)}
                                >
                                    {medida.tipo}: {medida.comp}m x {medida.larg}m = {medida.area.toFixed(2)} m²
                                </div>
                            ))
                        )}
                    </div>
                </div>

                {/* Botões de ação para o formulário principal */}
                <div className="flex flex-wrap gap-4 mb-6">
                    <button className="button-primary" onClick={salvarUnidade}>Salvar Unidade</button>
                    <button className="button-secondary" onClick={limparCampos}>Nova Unidade</button>
                    <button className="button-primary" onClick={exportarExcelEEmail}>Exportar Excel e Enviar Email</button>
                </div>

                {/* Seção de Localidades Salvas */}
                <h2 className="text-xl font-semibold text-gray-800 mb-4">Localidades Salvas</h2>
                <div className="listbox h-48">
                    {Object.keys(localidades).length === 0 ? (
                        <p className="p-2 text-gray-500">Nenhuma localidade salva.</p>
                    ) : (
                        // Mapeia e exibe as localidades e unidades salvas
                        Object.entries(localidades).flatMap(([local, units]) =>
                            Object.keys(units).sort().map(unit => (
                                <div
                                    key={`${local}-${unit}`}
                                    className={`listbox-item ${selectedLocalidadeUnit?.localidade === local && selectedLocalidadeUnit?.unidade === unit ? 'selected' : ''}`}
                                    onClick={() => carregarLocalidade(local, unit)}
                                >
                                    {local} - {unit}
                                </div>
                            ))
                        )
                    )}
                </div>
            </div>
        </div>
    );
}

export default App;
